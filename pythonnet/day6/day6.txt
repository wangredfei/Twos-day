前情回顾

1. 进程相关函数
   os.getpid()
   os.getppid()
   os._exit()
   sys.exit()
2. 孤儿进程  和 僵尸进程

   处理僵尸进程   wait()  waitpid()
   创建二级子进程

3. 聊天室
   确定需求---> 基本技术分析-->整体设计-->功能分析-->编码实现 --> 代码测试
***********************************************

注意 : 
    如果子进程从父进程继承对象,则父子进程使用此对象可能会相互影响
    但是如果对象是子进程创建后,在各自进程中生成的则一定没有影响


multiprocessing 模块创建进程

1. 将需要执行的进程事件封装为函数
2. 使用模块中的Process 类生成进程对象,并关联相关函数
3. 可以通过对象属性设置进程信息
4. 通过进程对象启动进程,此时自动运行进程函数
5. 回收进程

Process()
功能 : 创建进程对象
参数 : target   绑定的目标函数
       name   进程名  默认Process-1
       args   元组,按位置给target函数传参
       kwargs  字典,按照键值对给target函数传参

p.start()
功能 : 启动进程
* target绑定的函数会自动执行,此时进程真正被创建

p.join([timeout])
功能: 阻塞等待回收进程
参数: 超时时间

* 使用multiprocessing创建进程,同样子进程复制父进程全   部代码空间,父子进程互不影响,各自运行,子进程相当于只   执行绑定函数

* join可以处理僵尸进程

* multiprocessing 中父进程可以更方便创建多个进程执行   多个事件.父进程往往将事件交由子进程完成


进程对象属性

p.name  进程名称
p.pid   进程号
p.is_alive()  进程状态(查看是否在生命周期)

p.daemon  
   默认是False 表示主进程退出,不会影响子进程继续运行
   如果设置为True 此时主进程退出,子进程也会结束
   * 要求在start()前设置


自定义进程类

适用情况 : 使用类将一系列功能进行封装,通过调用类中的            方法完成较复杂的功能

步骤 : 
1. 继承Process类
2. 编写自己的__init__添加属性
   使用super重新加载父类__init__方法
3. 重写run方法,完成功能逻辑调用

使用:
1.使用自定义类实例化对象
2.使用实例化对象调用 start() 则创建新的进程,自动运行   run方法
3. 使用对象调用join()则回收进程



多进程 

优点 : 可以使用计算机多核资源,同时运行多个任务,提高运        行效率
缺点 : 进程的创建和删除过程需要消耗较多的系统资源.大        量进程频繁的创建删除会给系统带来压力


进程池技术

产生原因 : 应对大量任务需要多进程完成,需要频繁创建删            除进程的情况

原理 : 创建一定量的进程作为进程池,用来处理事件.
       事件处理完毕后,进程不退出,而是继续等待处理其他事件.直到所有待处理事件处理完毕后统一销毁进程.增加了进程的重复利用,降低资源消耗.

使用方法 : 
1. 创建进程池,放入适当的进程
2. 将要做的事件封装为函数,放入进程池等待队列
3. 进程池中的进程会不断执行队列中的事件直到全部被执    行
4. 关闭进程池,回收进程

from multiprocessing import Pool

pool = Pool(processes)
功能 : 创建进程池对象
参数 : 指定进程池中进程数据量,默认根据系统自动判定

pool.apply_async(func,args,kwds)
功能: 放入要执行的事件函数
参数 : func  事件函数
       args  元组 给函数按位置传参
       kwds  字典 给函数按键值传参
返回值 :返回函数事件对象,调用get()可以获取func返回值

pool.apply(func,args,kwds)
功能: 放入要执行的事件函数
参数 : func  事件函数
       args  元组 给函数按位置传参
       kwds  字典 给函数按键值传参

pool.map(func,iter)
功能: 将函数事件放入进程池执行
参数:  func  要执行的函数
       iter  可迭代对象,用于给func传参
返回值: 函数的返回值列表

pool.close()
功能 : 关闭进程池,无法再添加新的事件

pool.join()
功能 : 阻塞等待回收进程池


进程间通信 (IPC)

原因 : 进程空间相对独立,资源无法直接获取.此时在不同        的进程间需要进行消息传输,即进程间通信


进程间通信方式: 管道   消息队列   共享内存   信号
                信号量   套接字

管道通信 (pipe)

通信原理 : 在内存中开辟管道空间,生成管道操作对象,进            程间使用同一组管道对象进行读写实现通信


from multiprocessing import Pipe

fd1,fd2 = Pipe(duplex = True)
功能 : 创建管道
参数 : 默认表示双向管道
       False表示单项管道
返回值: 表示管道两端的读写对象
        如果是双向管道,则fd1,fd2均可读写
	如果是单向管道,则fd1只读,fd2只写

fd.recv()
功能 : 从管道读取内容
返回值 : 读到的内容

* 如果管道为空则阻塞

fd.send(data)
功能 : 向管道写入内容
参数 : 要写入的内容

* 可以写入Python格式数据



消息队列 (queue)

队列 : 先进先出

通信原理 : 在内存中建立队列模型,进程通过队列对象将消            息存入到队列,或者从队列取出消息,完成进程            间通信.被先放入的消息一定先取出

from multiprocessing import Queue 

q = Queue(maxsize=0)
功能 : 创建消息队列
参数 : 表示队列中最多存放多少消息 
返回值 : 队列对象

q.put(data,[block,timeout])
功能: 向队列存入消息
参数: data  要存入的内容  Python 数据
      block 默认队列满会阻塞,设置为False则为非阻塞
      timeout 超时检测

data = q.get([block,timeout])
功能 : 从队列中获取消息
参数 : block  默认队列空阻塞,设置False为非阻塞
       timeout 超时检测
返回值 : 获取到的数据

q.full() 判断队列是否为满
q.empty() 判断队列是否为空
q.qsize() 获取队列中消息个数
q.close() 关闭队列

作业 : 1. 整理 multiprocessing 和fork创建进程方法
       2. 复习tcp和udp通信 
       3. http协议  mysql操作
